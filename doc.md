# 基于GraphCut的纹理合成

2017013599 从业臻

### 一、运行环境

**系统：**Windows10

**语言：**Python 3.7

**依赖：**PyMaxflow, NumPy, opencv-python

### 二、功能实现

- 所有基础要求
- **切割算法改进----处理 surrounded regions，1'**
- **切割算法改进----考虑旧的切割，1'**
- **切割算法改进----能量函数引入梯度信息，1'**
- **偏移算法加速----快速傅里叶变换，3'**

加分项**总计5'**。

### 三、代码思路

### 1 块切割算法

##### 1.1 建立图结构

设最终的合成图片大小为$(H, W)$，纹理图片大小为$(h,w)$。合成图片初始为全0的$H\times W \times 3$数组，下面成为***画布***。使用了一个二维数组$filled$记录画布每个像素点是否已经被纹理覆盖。

我考虑了新旧区域重合区域为**任意可能（包括surrounded regions的情况）**，但新区域一定是矩形的情况。这种情况下，需要构造三种边：

- 遍历新区域，根据$filled$得到重合区域，并产生重合区域内部相邻点之间的边（双向）。

- 遍历新区域的边界，如果属于重合区域，且向外延伸一个像素点（比如上边界，向外延伸就是向上一个像素；右边界的延伸就是向右一个像素）属于旧区域，那么该像素点落在旧区域和重合区域的交汇处，应有一条以该像素点为终点，以源为始点，流量为$\infty$的边。

- 遍历新区域，如果属于重合区域，且周围任意一格满足：

  1. 仍在新区域内
  2. 不属于旧区域

  那么该像素点落在新区域和重合区域的交汇处，应有一条以该像素点为始点，以汇为终点，流量为$\infty$的边。

边的添加使用`PyMaxflow`库的`maxflow.Graph.add_edge`和`maxflow.Graph.add_tedge`实现。

特别地，如果新区域被完全包围，则选择其中心像素点与汇相连。

##### 1.2 求解最小割

由最小割最大流定理，求最小割即是求最大流，使用`PyMaxflow`库的`maxflow.Graph.maxflow`实现。

##### 1.3 像素拷贝

`maxflow.Graph.get_grid_segments`则给出了求解最大流之后，对图中端点的分类（即源和最小割之间还是最小割和汇之间）。根据该分类矩阵，可以选择性的将纹理的像素点拷贝到画布上。

##### 1.4 能量函数

实现了**引入梯度信息的能量函数**。由于计算能量函数总开销很小，我直接对每个边单独调用该函数。

##### 1.5 考虑旧切割

将维护两个矩阵，分别记录纵向和横向的切割，数据包括边的能量函数，边两节点的像素值（新旧patch），以实现后续添加seam node时能量函数的计算。

#### 2 块偏移生成算法

##### 2.1 随机生成

行列分别产生一个$[0, H-h]$和$[0,W-w]$范围内的随机数作为偏移即可。

##### 2.2 最佳位置匹配

遍历所有可能情况，计算SSD本身很简单，但是实验发现对于稍大一些的图（比如🍓）开销就有点过高了。因此，实现了基于$summed~table$和$FFT$的加速。

首先，暴力遍历的方法，时间复杂度为$O((H-h)(W-w)hw)$，对于大多数情况，$H,W$分别是$h,w$的若干倍（下面也都默认这样的情况分析，用$h,w$替代$H, W$），那么时间复杂度约为$O(h^2w^2)$，对于$200\times200$的纹理来说，已经是一个很高的复杂度了。参考课件和项目说明：

![image-20201208192613972](C:\Users\13731\AppData\Roaming\Typora\typora-user-images\image-20201208192613972.png)

其中第二项对于画布所有位置都一样，开销为$O(hw)$；第一项可以使用预积分表计算（使用`numpy.cumsum`高效计算），开销为$O(HW)=O(hw)$；第三项则可以使用快速傅里叶变换计算（使用`cv2.filter2D`），开销为$O(hw~log(hw))$。总复杂度为$O(hw~log(hw))$，理论上应该比暴力方法快很多。

注意到这里其实有个小细节，即对画布某个位置，代价函数应为

$$\frac{\sum_{p} [filled(p-t)((I(p-t)-O(p))]^2}{\sum_{p}filled(p-t)}$$，

这样实际上原本的第二项应该是$\sum_p O(p)^2*filled(p-t)^2$，不过这不是问题，只不过是另一个快速傅里叶变换计算；此外，上式分母也使用预积分表计算。总的复杂度仍是$O(hw~log(hw))$。

##### 2.3 生成概率分布

得到所有位置的代价函数值后，使用一系列`numpy`操作生成概率密度，进行`numpy.cumsum`得到分布数组，然后`for`循环遍历判断即可。

##### 2.4 子块最佳位置匹配

匹配原理同2.2。

##### 2.5 额外规则

为了更快地填充整个画布的同时尽可能保证接缝的平滑，我规定了单次操作，新旧区域重合面积不小于某个阈值（新区域的10%），也不大于某个阈值（新区域的70%）；如果重合面积一定会大于某个阈值，那么优先选取重合面积小的。

### 四、实验结果

#### 3.1 策略说明

#### 3.2 合成图片展示

**🍓：**

![strawberry](res\strawberry.jpg)

**绿色纹理：**

![test1](res\green.jpg)

**键盘：**

![test1](res\keyboard.jpg)

#### 3.3 能量函数引入梯度前后比较

#### 3.4 考虑old seam前后比较



#### 3.5 使用预积分表与FFT加速前后比较

### 五、总结

这个项目收获丰富，包括但不限于：

- 阅读论文和课件动手实现一个经典算法
- 学习预积分表、FFT这两个优化技巧
- 更加熟悉`opencv-python`&`NumPy`，且学习了`PyMaxflow`
- 锻炼编程能力

感谢老师与助教的指导！



